#!/usr/bin/env python3
"""
Simple listing and switching for IKEA Tradfri lighting gateway.

To run the script, do the following:
$ pip3 install pytradfri
$ ./on.py <IP> [<ID> <level>]
where:
    <IP> is the name or IP address of the Tradfri gateway (e.g., 10.0.0.100).
    <ID> is the id number of the device to control (e.g., 65540)
    <level> is the light level 0 to 254.

To set up the pre-shared key, one of the github examples will need to be
run once to create the config file.
"""
# Default location from git repository
CONFFILE="examples/tradfri_standalone_psk.conf"

import sys
from pytradfri import Gateway
from pytradfri.device import Device
from pytradfri.api.libcoap_api import APIFactory
from pytradfri.util import load_json

class Switchable:
    """
    A class to abstract a Light/LightControl/Device or
    Socket/SocketControl/Device with its associated gateway
    into a single class.
    """
    
    def __init__(self,api,gateway,dev):
        self.dev=dev
        self.api=api
        self.gateway=gateway
    
    def dev(self):
        return self.dev

    @property
    def id(self):
        return self.dev.id
    
    @property
    def name(self):
        return self.dev.name

    @property
    def controller(self):
        if self.dev.has_light_control:
            return self.dev.light_control
        if self.dev.has_socket_control:
            return self.dev.socket_control
        return None
        
    @property
    def state(self):
        if hasattr(self.controller,"lights"):
            return self.controller.lights[0]
        if hasattr(self.controller,"sockets"):
            return self.controller.sockets[0]
        return None
    
    def update(self):
        self.dev=self.api(self.gateway.get_device(self.id))
    
    def leveltotext(self,level):
        if level is None or level<0:
            return "unk"
        if level>254:
            return "on "
        if level==0:
            return "off"
        return format(level)

    @property
    def leveltext(self):
        return self.leveltotext(self.level)

    @property
    def level(self):
        s=self.state
        if s is None:
            return -1
        if not s.state:
            return 0
        if hasattr(s,"dimmer"):
            return s.dimmer
        return 255

    def set_level(self,level):
        c=self.controller
        try:
            if level>0:
                self.api(c.set_dimmer(level))
        except AttributeError:
            pass

        self.api(c.set_state(level>0))

    def reprline(self):
        return "{0} {1:3} {2}".format(self.id,self.leveltext,self.name)

    def __repr__(self):
        if self.state:
            return self.state.__repr__()
        if self.controller:
            return self.controller.__repr__()
        return self.dev.__repr__()

def run(args):
    # Assign configuration variables.
    id=-1
    level=-1
    args.pop(0)
    ip=args.pop(0)
    if args:
        id = int(args.pop(0))
    if args:
        level=int(args.pop(0))

    conf=load_json(CONFFILE)
    if not conf:
        print("Could not load {}:".format(CONFFILE))
        print("pre-shared-key (generated by gateway device) needed: see example_sync.py")
        return

    identity=conf[ip].get('identity')
    psk=conf[ip].get('key')
    api = APIFactory(host=ip,psk_id=identity,psk=psk).request
    gateway = Gateway()

    devices = api(api(gateway.get_devices()))
    lights = [Switchable(api,gateway,dev) for dev in devices if dev.has_light_control or dev.has_socket_control]

    if id<0:
        # Print all lights
        for l in lights:
            print(l.reprline())
        return

    ids = [l.id for l in lights]
    if not id in ids:
        print("id not found ({} lights)".format(len(lights)))
        return

    i=ids.index(id);
    light=lights[i]

    prelevel=light.leveltext
    light.set_level(level)
    light.update()
    print("{} -> {}".format(prelevel,light.leveltext))

run(sys.argv)
